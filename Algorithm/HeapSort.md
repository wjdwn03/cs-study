# 힙 정렬<sub> Heap Sort</sub>

> 최대 힙 트리나 최소 힙 트리를 구성해 정렬하는 방법

> 힙<sub>Heap</sub> : 최솟값이나 최댓값을 빠르게 찾아내기 위해 완전 이진 트리를 기반으로 하는 트리    
> 힙 종류 : `최대 힙`, `최소 힙`

### 특징
- 힙 정렬을 하기 위해 정해진 데이터를 힙 구조를 가지도록 만들어야 함.
- **내림차순** 정렬 : <u>최대 힙</u>을 구성
- **오름차순** 정렬 : <u>최소 힙</u>을 구성
- heapify : 최대 힙으로 만드는 과정
    - 트리 깊이만큼 수행하기 때문에 heapify의 시간 복잡도는 $O(log N)$
- 힙정렬과 퀵정렬을 비교해보면 똑같은 nlogn 이지만 컴퓨터의 하드웨어 구조상 퀵정렬이 실제로는 더 빠르다고 함.
    - 이유는 퀵 정렬의 경우는 대개 원소들끼리 근접한 메모리 영역에 붙어 있는 배열을 사용하기 때문에 일반적으로 캐시 친화적이지만 힙정렬의 원소들은 좀 더 흩어져 있는 경우가 많아서 캐시 친화도가 떨어지는 문제가 있고 힙정렬은 일반적으로 포인터 연산을 많이 사용하기 때문에 거기에 걸리는 오버헤드도 무시할 수는 없는 수준이기 때문
- 제자리 정렬
- 불안정 정렬

### 장점
- 최악의 경우에도 O(NlogN)의 성능을 보이며, 추가적인 메모리 공간을 사용하지 않음.
    - 최선, 평균, 최악의 경우의 모두 heapify 과정이 필요하기 때문에 NlogN 을 보장

### 단점
- 구현이 복잡

### 동작 원리
1. n개의 노드에 대한 완전 이진 트리를 구성한다. 이때 루트 노드부터 부모노드, 왼쪽 자식노드, 오른쪽 자식노드 순으로 구성한다.
1. 최대 힙을 구성한다. 최대 힙이란 부모노드가 자식노드보다 큰 트리를 말하는데, 단말 노드를 자식노드로 가진 부모노드부터 구성하며 아래부터 루트까지 올라오며 순차적으로 만들어 갈 수 있다.
1. 가장 큰 수(루트에 위치)를 가장 끝의 노드와 교환한다.
1. 모두 정렬될 때까지 2와 3을 반복한다.

</br>

### Heap Sort 구현

</br>

### 복잡도<sub>Complexity</sub>
<table style="text-align:center">
  <tr>
    <td ></td>
    <td colspan="3">시간 복잡도</td>
    <td rowspan="2">공간 복잡도</td>
  </tr>
  <tr>
    <td></td>
    <td >최선</td>
    <td>평균</td>
    <td>최악</td>
  </tr>
  <tr>
    <td><b>Heap Sort</b></td>
    <td>O(NlogN)</td>
    <td>O(NlogN)</td>
    <td>O(NlogN)</td>
    <td>O(1)</td>
  </tr>
</table>


</br>
</br>

- 참고

[정렬의 뜻, 정렬 알고리즘 분류 방법](https://hellowoori.tistory.com/48)
[[알고리즘] 힙 정렬(Heap Sort)](https://hongcoding.tistory.com/186)