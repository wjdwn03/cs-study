## ìµœì†Œ ê³µí†µ ì¡°ìƒ LCA(Lowest Common Ancestor) ì•Œê³ ë¦¬ì¦˜ì´ë€?
 - LCAëŠ” ì£¼ì–´ì§„ ë‘ ë…¸ë“œ A,Bì˜ ìµœì†Œ ê³µí†µ ì¡°ìƒì„ ì°¾ëŠ” ì•Œê³ ë¦¬ì¦˜ì´ë‹¤.

   ì˜ˆë¥¼ë“¤ë©´ ìœ„ì˜ ê·¸ë¦¼ì—ì„œ 5ë²ˆê³¼ 6ë²ˆë…¸ë“œì˜ LCAëŠ” 2ë²ˆë…¸ë“œì´ë‹¤.

   ## ğŸ“ í’€ì´ë°©ë²•
   - ì¼ë°˜ì  í’€ì´
     1.1ë²ˆ ë£¨íŠ¸ë…¸ë“œë¥¼ ê¸°ì¤€ìœ¼ë¡œ DFSë¥¼ ëŒë ¤ì„œ ê° ë…¸ë“œì˜ ë†’ì´ì™€ ë¶€ëª¨ë…¸ë“œë¥¼ ì €ì¥í•œë‹¤.
     2.ë‘ ë…¸ë“œì˜ ë†’ì´ë¥¼ ê°™ê²Œ ë§ì¶°ì¤€ë‹¤(ë°¸ëŸ°ìŠ¤ ë§ì¶”ëŠ” ê²ƒ ì´ì•¼ê¸°í•˜ëŠ” ê²ƒ ê°™ìŒ)
     3.ë¶€ëª¨ë…¸ë“œê°€ ì¼ì¹˜í• ë•Œê¹Œì§€ ë¹„êµí•œë‹¤.(ìµœëŒ€ 1ë²ˆë…¸ë“œ)

     í•˜ì§€ë§Œ ì´ ë°©ì‹ì€ í¸í–¥ëœ íŠ¸ë¦¬ë¥¼ ë§Œë‚˜ë©´ ì—„ì²­ë‚œ ì—°ì‚°ì„ ìš”êµ¬í•˜ê²Œ ëœë‹¤.
     ë”°ë¼ì„œ ë” íš¨ìœ¨ì ì¸ ë°©ì‹ì„ ìš”êµ¬í•œë‹¤.

   - DP
     2^hì˜ ë¶€ëª¨ë¥¼ ì•Œë©´ ì—°ì‚°ì˜ íšŸìˆ˜ê°€ ë§¤ìš° ì¤„ì–´ë“ ë‹¤.
     dp[cur][h] = 2ì°¨ì›ë°°ì—´ì— í˜„ì¬ ë…¸ë“œì˜ 2^hë²ˆì§¸ ë¶€ëª¨ë…¸ë“œë¥¼ ì €ì¥í•œë‹¤.
  1. íŠ¸ë¦¬ì˜ ìµœëŒ€ ë†’ì´ hë¥¼ êµ¬í•œë‹¤.// (Math.log(n)/Math.log(2))-> n= 2^h-1 -> log n = h log 2
     ```
     static int getTreeHeight() {
	return(int)Math.ceil(Math.log(n)/Math.log(2)) +1;
}
     ```
  3. dfsíƒìƒ‰ì„ í†µí•´ ê° ë…¸ë“œì˜ ë†’ì´(depth)ë¥¼ êµ¬í•œë‹¤.+ dp[node][0] = ì²«ë²ˆì§¸ ë¶€ëª¨ë…¸ë“œ (2^0=1)ë¡œ ì´ˆê¸°í™”
  ```
static void init(int cur, int h, int pa) {
	depth[cur] = h;// ë†’ì´ ì €ì¥
	for(int nxt : list[cur]) {// í•˜ìœ„ ë…¸ë“œë“¤ì— ëŒ€í•˜ì—¬ 
		if(nxt != pa) {// í˜„ ë…¸ë“œì™€ ì—°ê²°ë˜ì–´ ìˆê³  ë™ì‹œì— í•˜í–¥ì‹ì¸ ë…¸ë“œë“¤ë§Œ 
			init(nxt, h+1, cur);// ì¬ê·€ 
			parent[nxt][0] = cur; // nxtì˜ ë¶€ëª¨ cur 
		}
	}
}
```
  4. ë‚¨ì€ 2^h-1ê¹Œì§€ ì±„ìš´ë‹¤.
     ```
static void fillParents() {
	for(int i=1; i<h; i++) {// dp[node][h] ì´ê³  0ì€ ìœ„ì—ì„œ ì´ˆê¸°í™” í•˜ì˜€ìœ¼ë¯€ë¡œ 1ë¶€í„° ì‹œì‘ ~ h-1ê¹Œì§€
		for(int j=1; j<n+1; j++) {//node ì „ì²´ì— ëŒ€í•œ 
			parent[j][i] = parent[parent[j][i-1]][i-1];// ë…¸ë“œ 15ì˜ 2^7ë²ˆì§¸ ë¶€ëª¨ë…¸ë“œëŠ” 15ë²ˆì˜ 2^6ë²ˆ ë¶€ëª¨ì˜ 2^6ë²ˆì§¸ë¶€ëª¨ì´ë‹¤? 
		}
	}
}

     ```
